#!/usr/bin/env python

import os
import sys

# This script automatically generates the AMDIL C++ AST code.


binary_operators = [
    ['iadd', 'IAddInstruction'],
    ['imad', 'IMadInstruction'],
]

unary_operators = [
    ['mov', 'MovInstruction'],
]


if len(sys.argv) != 2:
    print('Usage:  generate-amdil-ast.py <output-path>')
    sys.exit(1)

outPath = sys.argv[1]

if not os.access(outPath, os.W_OK):
    print('No write access to %s' % outPath)
    sys.exit(1)
    

headerName = os.path.join(outPath, 'GeneratedInstructions.hpp')
sourceName = os.path.join(outPath, 'GeneratedInstructions.cpp')
parserName = os.path.join(outPath, 'ParserSupport.inl')

#print('Writing Files:  %s, %s' % (headerName, sourceName))


headerFile = open(headerName, 'w')
sourceFile = open(sourceName, 'w')
parserFile = open(parserName, 'w')

if not headerFile or not sourceFile or not parserFile:
    print('Unable to open output files.')
    sys.exit(1)


# Write file headers
headerFile.write("""
// This file is automatically generated.  Please do not modify by hand.

#if !defined(GPU_BIN_TOOLS_AMDIL_GENERATED_INSTRUCTIONS_HPP_INC)
#define GPU_BIN_TOOLS_AMDIL_GENERATED_INSTRUCTIONS_HPP_INC 1

namespace gpubintools
{
namespace amdil
{

class Operand;

""")

sourceFile.write("""
// This file is automatically generated.  Please do not modify by hand.

#include \"gpubintools/Common.hpp\"
#include \"gpubintools/amdil/Operand.hpp\"
#include \"gpubintools/amdil/GeneratedInstructions.hpp\"


namespace gpubintools
{
namespace amdil
{

""")



# Write the basic instruction classes
headerFile.write("""

/**
 * Base class for all AMDIL AST instructions.
 */
class Instruction
{
public:

  /**
   * Constructor.
   */
  Instruction();

  /**
   * Destructor.
   */
   virtual ~Instruction();
};

/**
 * An AMDIL unary operator instruction.
 */
class UnaryOperator : public Instruction
{
public:

  /**
   * Constructor.
   *
   * @param[in] dest    The destination operand.
   * @param[in] source  The source operand.
   */
  UnaryOperator(Operand* dest,
                 Operand* source);

  /**
   * Destructor.
   */
  virtual ~UnaryOperator();


private:

  Operand* dest_;
  Operand* source_;
  
};


/**
 * An AMDIL binary operator instruction.
 */
class BinaryOperator : public Instruction
{
public:

  /**
   * Constructor.
   *
   * @param[in] dest        The destination operand.
   * @param[in] leftSource  The left source operand.
   * @param[in] rightSource The right source operand.
   */
  BinaryOperator(Operand* dest,
                 Operand* leftSource,
                 Operand* rightSource);

  /**
   * Destructor.
   */
  virtual ~BinaryOperator();


private:

  Operand* dest_;
  Operand* leftSource_;
  Operand* rightSource_;
  
};

""")


sourceFile.write("""

Instruction::Instruction()
{
}

Instruction::~Instruction()
{
}

UnaryOperator::UnaryOperator(Operand* dest,
                             Operand* source)
  : dest_(dest),
    source_(source)
{
}

UnaryOperator::~UnaryOperator()
{
}

BinaryOperator::BinaryOperator(Operand* dest,
                               Operand* leftSource,
                               Operand* rightSource)
  : dest_(dest),
    leftSource_(leftSource),
    rightSource_(rightSource)
{
}

BinaryOperator::~BinaryOperator()
{
}

""")



# Write out the concrete unary operators

parserFile.write("""
  #define UNARY_OPERATOR(text, skip, klass)                             \
  else if(ba::starts_with(line, #text))                                 \
  {                                                                     \
    std::string  rest     = line.substr(skip);                          \
    StringVector operands;                                              \
                                                                        \
    ba::split(operands, rest, boost::is_any_of(","));                   \
                                                                        \
    if(operands.size()   != 2)                                          \
    {                                                                   \
      std::cerr << \"unary operators can contain only 2 operands.\" << std::endl; \
      return NULL;                                                      \
    }                                                                   \
                                                                        \
    ba::trim(operands[0]);                                              \
    ba::trim(operands[1]);                                              \
                                                                        \
    Operand*     dest    = parseOperand(operands[0]);                   \
    Operand*     source0 = parseOperand(operands[1]);                   \
                                                                        \
    Instruction* instr   = new klass(dest, source0);                    \
                                                                        \
    file->appendInstruction(instr);                                     \
  }
""")


for unop in unary_operators:

  headerFile.write('class %s : public UnaryOperator\n' % unop[1])
  headerFile.write('{\n')
  headerFile.write('public:\n')
  headerFile.write('  /**\n')
  headerFile.write('   * Constructor.\n')
  headerFile.write('   *\n')
  headerFile.write('   * @param[in] dest    The destination operand.\n')
  headerFile.write('   * @param[in] source  The source operand.\n')
  headerFile.write('   */\n')
  headerFile.write('  %s(Operand* dest,\n' % unop[1])
  headerFile.write('     Operand* source);\n')
  headerFile.write('  /**\n')
  headerFile.write('    * Destructor.\n')
  headerFile.write('    */\n')
  headerFile.write('  virtual ~%s();\n' % unop[1])
  headerFile.write('};\n\n')
  
  sourceFile.write('%s::%s(Operand* dest,\n' % (unop[1], unop[1]))
  sourceFile.write('       Operand* source)\n')
  sourceFile.write('  : UnaryOperator(dest, source)\n')
  sourceFile.write('{\n')
  sourceFile.write('}\n\n')
  sourceFile.write('%s::~%s()\n' % (unop[1], unop[1]))
  sourceFile.write('{\n')
  sourceFile.write('}\n\n')

  parserFile.write('UNARY_OPERATOR(%s, %d, %s)\n' % (unop[0], len(unop[0]), unop[1]))




# Write out the concrete binary operators

parserFile.write("""
  #define BINARY_OPERATOR(text, skip, klass)                              \
  else if(ba::starts_with(line, #text))                                 \
  {                                                                     \
    std::string  rest     = line.substr(skip);                          \
    StringVector operands;                                              \
                                                                        \
    ba::split(operands, rest, boost::is_any_of(","));                   \
                                                                        \
    if(operands.size()   != 3)                                          \
    {                                                                   \
      std::cerr << \"binary operators can contain only 3 operands.\" << std::endl; \
      return NULL;                                                      \
    }                                                                   \
                                                                        \
    ba::trim(operands[0]);                                              \
    ba::trim(operands[1]);                                              \
    ba::trim(operands[2]);                                              \
                                                                        \
    Operand*     dest    = parseOperand(operands[0]);                   \
    Operand*     source0 = parseOperand(operands[1]);                   \
    Operand*     source1 = parseOperand(operands[2]);                   \
                                                                        \
    Instruction* instr   = new klass(dest, source0, source1);           \
                                                                        \
    file->appendInstruction(instr);                                     \
  }
""")


for binop in binary_operators:

  headerFile.write('class %s : public BinaryOperator\n' % binop[1])
  headerFile.write('{\n')
  headerFile.write('public:\n')
  headerFile.write('  /**\n')
  headerFile.write('   * Constructor.\n')
  headerFile.write('   *\n')
  headerFile.write('   * @param[in] dest        The destination operand.\n')
  headerFile.write('   * @param[in] leftSource  The left source operand.\n')
  headerFile.write('   * @param[in] rightSource The right source operand.\n')
  headerFile.write('   */\n')
  headerFile.write('  %s(Operand* dest,\n' % binop[1])
  headerFile.write('     Operand* leftSource,\n')
  headerFile.write('     Operand* rightSource);\n')
  headerFile.write('  /**\n')
  headerFile.write('    * Destructor.\n')
  headerFile.write('    */\n')
  headerFile.write('  virtual ~%s();\n' % binop[1])
  headerFile.write('};\n\n')
  
  sourceFile.write('%s::%s(Operand* dest,\n' % (binop[1], binop[1]))
  sourceFile.write('       Operand* leftSource,\n')
  sourceFile.write('       Operand* rightSource)\n')
  sourceFile.write('  : BinaryOperator(dest, leftSource, rightSource)\n')
  sourceFile.write('{\n')
  sourceFile.write('}\n\n')
  sourceFile.write('%s::~%s()\n' % (binop[1], binop[1]))
  sourceFile.write('{\n')
  sourceFile.write('}\n\n')

  parserFile.write('BINARY_OPERATOR(%s, %d, %s)\n' % (binop[0], len(binop[0]), binop[1]))


# Finalize the files
headerFile.write("""

}
}

#endif
""")

sourceFile.write("""

}
}
""")
